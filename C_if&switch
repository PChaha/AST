# AST
def main():
    get_function_info_pattern = re.compile(r"(static)*\s*(\w+)\s(\*?)(\w+)\s*\(.*\)")  # 提取函数定义行
    get_call_function_info_pattern = re.compile(r"(\w+)\s*\(.*\)")  # 提取调用函数的正则表达式
    body_list_name = []  # 存放所有.c文件的路径
    head_list_name = []  # 存放所有.h文件的路径
    function_info_dict = {}  # 存放函数信息
    call_normal_function_name = []  # 当前检索的非硬件差异函数内调用的非硬件差异函数名称
    call_normal_function_path = []  # 当前检索的非硬件差异函数内调用的非硬件差异函数路径
    call_hard_function_name = []  # 当前检索的非硬件差异函数内调用的硬件差异函数名称
    call_hard_function_path = []  # 当前检索的非硬件差异函数内调用的硬件差异函数路径
    returntype_list = []  # 存放所有返回值类型（包括自定义返回值类型）
    function_name = ""  # 当前读取函数的函数名
    hard_function_name = []  # 存放所有差异函数名
    call_function_list = []  # 用于去重
    macrodef_name = []  # 存放所有宏定义
    globalvar_name = []  # 存放所有全局变量
    use_macrodef_name = []  # 存放当前检索的硬件差异函数内，pathstatement内使用的宏定义
    use_globalvar_name = []  # 存放当前检索的硬件差异函数内，pathstatement内使用的全局变量
    file_number = 1   # 用于json文件命名
    # 输入文件判断
    filePath = input("请输入工程路径: \n")
    while not os.path.isdir(filePath):
        print("路径不存在,请检查")
        filePath = input("请输入路径路径: \n")
    time_start = time.time()  # 开始计时
    project_name = "Soft:" + os.path.basename(filePath)  # 存储工程名
    project_path = filePath  # 存储工程路径
    read_files(filePath, body_list_name, head_list_name)
    returntype_search(body_list_name + head_list_name, returntype_list)
    hard_function_search(hard_function_name)
    macrodef_globalvar_search(macrodef_name, globalvar_name)
    function_search(body_list_name, function_info_dict, returntype_list)
    for pyFilePath in body_list_name:
        all_function_brackets_number = 0  # 记录当前"{}"是否成对
        hard_function_brackets_number = [0]  # 记录if分支语句内"{}"是否成对（包括嵌套的分支）(可扩充)
        floorblock_level = [0]  # 当前if层块的分支号(可扩充)
        path_dict = {}  # 存放分层分块后if路径的字典
        path_list = []  # 存放所有划分好的路径
        floornumber_list = [1, 1]  # 按路径分支号划分路径时的起始位置
        pathnumber_list = []  # 存放所有路径分支号
        basepath = ""  # 用于存放除if、switch的分支路径外的所有路径
        endpath = ""
        pathstatement = []
        function_judge = "no"  # 判断当前函数是否为差异函数，”yes“为差异函数，”no“为非差异函数
        temp_path_list = []
        no_return_list = []  # 存放没有return的最小路径块
        no_return_list_dict = {}  #
        relationship = []  # 存放一条基本路径内的每一条语句之间的关联关系
        block_info = ""  # 存放block信息
        switch_path_judge = 0  # 判断是否为switch分支
        switch_condition = ""  # 存放switch条件
        temp_base_path = ""
        notes_lock = 0  # 注释锁
        # 当读取到新文件时，将前一个文件的读取信息清空
        call_normal_function_name.clear()
        call_normal_function_path.clear()
        call_hard_function_name.clear()
        call_hard_function_path.clear()
        sourcename = "SF:" + os.path.basename(pyFilePath) + ";" + project_name  # 存储源文件名
        sourcepath = pyFilePath  # 存储源文件路径
        contents = read(pyFilePath)  # 读取文件内容
        for content in contents:
            if "//" in content:
                content = content[:content.index("//")]
            if "/*" in content:
                notes_lock = 1
            if "*/" in content:
                notes_lock = 0
            if content.strip() == "" or notes_lock == 1:
                continue
            if "{" in content:
                all_function_brackets_number += 1
            if "}" in content:
                all_function_brackets_number -= 1
            # 通过正则表达式获取列表中符合要求的行
            method_info = get_function_info_pattern.findall(content)
            callfunction_info = get_call_function_info_pattern.findall(content)
            # 若字符串长度不为0，则代表读取到新函数
            if method_info.__len__() > 0:
                if method_info[0][1] in returntype_list:
                    # 清空上一个函数中的路径信息
                    if method_info[0][3] not in hard_function_name:
                        function_name = "NF:" + method_info[0][3] + ";" + sourcename  # 存放当前函数名
                    else:
                        function_judge = "yes"
                        function_name = "HF:" + method_info[0][3] + ";" + sourcename  # 存放当前函数名
            if function_judge == "no":
                if callfunction_info.__len__() > 0:  # 若字符串长度不为0，则代表获取到了可能是调用函数的信息
                    if all_function_brackets_number != 0:
                        # 对型如if(fish()>0)的格式进行判断
                        temp_content = content
                        while "(" in temp_content and callfunction_info.__len__() > 0:
                            if functionincall(callfunction_info[0], function_info_dict):  # 函数调用判断
                                if callfunction_info[0] not in call_function_list:  # 去重
                                    if callfunction_info[0] not in hard_function_name:  # 非硬件差异函数内调用的非硬件差异函数
                                        call_function_list.append(callfunction_info[0])
                                        call_normal_function_name.append(
                                            "NF:" + callfunction_info[0] + ";SF:" + os.path.basename(
                                                function_info_dict.get(callfunction_info[0])) + ";" + project_name)
                                        call_normal_function_path.append(function_info_dict.get(callfunction_info[0]))
                                    else:  # 非硬件差异函数内调用的硬件差异函数
                                        call_function_list.append(callfunction_info[0])
                                        call_hard_function_name.append(
                                            "HF:" + callfunction_info[0] + ";SF:" + os.path.basename(
                                                function_info_dict.get(callfunction_info[0])) + ";" + project_name)
                                        call_hard_function_path.append(function_info_dict.get(callfunction_info[0]))
                            temp_content = temp_content[temp_content.index("(") + 1:]
                            callfunction_info = get_call_function_info_pattern.findall(temp_content)
                if all_function_brackets_number == 0 and (
                        call_normal_function_name.__len__() > 0 or call_hard_function_name.__len__() > 0) and function_name != "":  # 判断当前函数分析结束且存在调用关系

                    json_file = open('medical' + str(file_number) + '.json', 'a', encoding='utf-8')
                    file_number += 1
                    kgdata = defaultdict(list)
                    kgdata["hardfunction"] = function_judge
                    kgdata["softwarename"] = project_name
                    kgdata["softwarepath"] = project_path
                    kgdata["sourcename"] = sourcename
                    kgdata["sourcepath"] = sourcepath
                    kgdata["function_name"] = function_name
                    kgdata["call_normal_function_name"] = call_normal_function_name
                    kgdata["call_normal_function_path"] = call_normal_function_path
                    kgdata["call_hard_function_name"] = call_hard_function_name
                    kgdata["call_hard_function_path"] = call_hard_function_path
                    json_str = json.dumps(kgdata, ensure_ascii=False)
                    json_file.write(json_str + "\n")
                    json_file.close()

                    function_name = ""
                    call_normal_function_name.clear()
                    call_normal_function_path.clear()
                    call_hard_function_name.clear()
                    call_hard_function_path.clear()
                    call_function_list.clear()
                    function_judge = "no"
            else:
                # if分支路径串、并联和switch分支判断
                if (("if(" in content or "if (" in content) and "else" not in content) or (
                        "else if(" in content or "else if (" in content) or (
                        "if(" not in content and "if (" not in content and "else" in content) or (
                        "switch" in content) or (
                        "case" in content) or (
                        "default" in content):  # 判断是否为分支语句，即判断分块的依据
                    if ("if(" in content or "if (" in content) and "else" not in content and \
                            hard_function_brackets_number[-1] == 0 and floorblock_level.__len__() > 1:
                        floorblock_level[-1] += 1
                    elif (("else if(" in content or "else if (" in content) or (
                            "if(" not in content and "if (" not in content and "else" in content)) and \
                            hard_function_brackets_number[-1] != 0:
                        floorblock_level[-1] += 1
                    elif ("if(" in content or "if (" in content) and "else" not in content:  # 判断是否为if语句，即判断层级的依据
                        if hard_function_brackets_number[-1] != 0 or hard_function_brackets_number.__len__() == 1:
                            floorblock_level[0] += 1
                            if floorblock_level.__len__() < floorblock_level[0] + 1:  # 层级每上升一层，分支号就扩充一位，“{}”记录列表也扩充一位
                                floorblock_level.append(1)
                                hard_function_brackets_number.append(0)
                    elif "switch(" in content or "switch (" in content:
                        switch_path_judge = 1
                        switch_condition = "Switch:" + content.strip().replace('{', '')
                        if floorblock_level.__len__() == 1:  # switch分支为第一个分支时
                            floorblock_level[0] += 1
                            floorblock_level.append(1)
                            hard_function_brackets_number.append(0)
                        else:
                            floorblock_level[-1] += 1
                    elif ("case " in content or "default:" in content) and switch_path_judge == 1:
                        if floorblock_level.__len__() == 2:
                            floorblock_level[0] += 1
                            floorblock_level.append(1)
                            hard_function_brackets_number.append(0)
                        else:
                            floorblock_level[-1] += 1
                else:
                    if basepath == "" and floorblock_level.__len__() == 1 and all_function_brackets_number != 0 and content.strip() != "{":
                        basepath = content.strip()
                    elif basepath != "" and floorblock_level.__len__() == 1 and all_function_brackets_number != 0:
                        basepath = basepath + "@" + content.strip()
                # if、switch层、块级判断
                if floorblock_level[0] != 0 or switch_path_judge == 1:
                    if switch_path_judge == 1:
                        content = content.replace('{', '')
                        if "}" in content:
                            content = content.replace('}', '')
                            switch_path_judge = 0
                            hard_function_brackets_number = hard_function_brackets_number[:-1]
                            floorblock_level = floorblock_level[:-1]
                            floorblock_level[0] -= 1
                    else:
                        if "}" in content or "{" in content:
                            if "}" in content:
                                content = content.replace('}', '')
                                if hard_function_brackets_number[floorblock_level[0]] > 0:
                                    hard_function_brackets_number[floorblock_level[0]] -= 1
                                elif hard_function_brackets_number[floorblock_level[0]] == 0:
                                    hard_function_brackets_number = hard_function_brackets_number[:-1]
                                    floorblock_level = floorblock_level[:-1]
                                    if floorblock_level.__len__() != 1:
                                        if content.strip() != "":
                                            floorblock_level[-1] += 1
                                        floorblock_level[0] -= 1
                                        hard_function_brackets_number[floorblock_level[0]] -= 1
                                    else:
                                        if basepath != "":
                                            endpath = basepath
                                        hard_function_brackets_number = [0]
                                        floorblock_level = [0]
                                        for path_key in path_dict.keys():
                                            del_index = []
                                            while "@@" in path_dict.get(path_key):
                                                path_dict[path_key] = path_dict.get(path_key).replace("@@",
                                                                                                      "@")
                                            if path_dict.get(path_key)[-1] == "@":
                                                path_dict[path_key] = path_dict.get(path_key)[:-1]
                                            path_key_list = list(map(int, path_key.split(",")))
                                            pathnumber_list.append(path_key_list)
                                            if "Switch:" in path_dict.get(path_key) and path_key.split(
                                                    ",").__len__() == 3:
                                                temp_string_list = list(path_dict.get(path_key))
                                                for temp_index, temp_str in enumerate(temp_string_list):
                                                    if "CB:" in path_dict.get(path_key):
                                                        if temp_str == "@" and temp_index > path_dict.get(
                                                                path_key).index("CB:"):
                                                            del_index.append(temp_index)
                                                    elif "DB:" in path_dict.get(path_key):
                                                        if temp_str == "@" and temp_index > path_dict.get(
                                                                path_key).index("DB:"):
                                                            del_index.append(temp_index)
                                                for temp_index in range(del_index.__len__()):
                                                    path_dict[path_key] = remove_char(path_dict.get(path_key),
                                                                                      del_index[
                                                                                          del_index.__len__() - temp_index - 1])
                                        print(path_dict)
                                        path_dict_key_index = 0
                                        for temp_key in path_dict.keys():
                                            if "Switch:" in path_dict[temp_key] and path_dict_key_index == 0:
                                                if "Switch:" not in path_dict[temp_key].split("@")[0]:
                                                    temp_base_path = path_dict[temp_key][
                                                                     :path_dict[temp_key].index("Switch:")]
                                            if "if" in path_dict[temp_key].split("@")[0] and temp_base_path != "":
                                                path_dict[temp_key] = temp_base_path + path_dict[temp_key]
                                                temp_base_path = ""
                                            path_dict_key_index += 1
                                        print(pathnumber_list)
                                        difffunction_path(pathnumber_list, path_list, floornumber_list, path_dict,
                                                          temp_path_list, no_return_list)
                                        print(path_list)
                                        print(no_return_list)
                                        print(endpath)
                                        #   遍历提取的每一条路径
                                        for single_path_list in path_list:
                                            #   判断路径中是否存在不含return的块
                                            inter = [temp_modular for temp_modular in no_return_list if
                                                     temp_modular in single_path_list]
                                            #   遍历一条路径中的每一个分支块
                                            temp_list_index = 0
                                            for temp_list_num, temp_list in enumerate(single_path_list):
                                                if temp_list == single_path_list[-1]:
                                                    temp_list_index += 1
                                                #   判断是否是路径链最后一块
                                                if temp_list_num != single_path_list.__len__() - 1:
                                                    modular_local = 0
                                                    #   首先存放非分支语句
                                                    while ("if" not in path_dict.get(int_to_str(temp_list)).split("@")[
                                                        modular_local]) and (
                                                            "else" not in
                                                            path_dict.get(int_to_str(temp_list)).split("@")[
                                                                modular_local]):
                                                        relationship.append("control")
                                                        pathstatement.append(
                                                            path_dict.get(int_to_str(temp_list)).split("@")[
                                                                modular_local])
                                                        modular_local += 1
                                                    if single_path_list[temp_list_num].__len__() == single_path_list[
                                                        temp_list_num + 1].__len__():
                                                        if ("if (" in path_dict.get(
                                                                int_to_str(single_path_list[temp_list_num + 1])).split(
                                                            "@")[
                                                            0] or
                                                            "if(" in path_dict.get(
                                                                    int_to_str(
                                                                        single_path_list[temp_list_num + 1])).split(
                                                                    "@")[0]) and \
                                                                "else" not in path_dict.get(
                                                            int_to_str(single_path_list[temp_list_num + 1])).split("@")[
                                                            0]:
                                                            relationship.append("control")
                                                        else:
                                                            relationship.append("false")
                                                    elif single_path_list[temp_list_num].__len__() < single_path_list[
                                                        temp_list_num + 1].__len__():
                                                        if "Switch:" in path_dict.get(
                                                                int_to_str(single_path_list[temp_list_num + 1])):
                                                            relationship.append("control")
                                                        else:
                                                            relationship.append("true")
                                                    else:
                                                        relationship.append("control")
                                                    #   存放分支语句
                                                    if temp_list_num == 0:
                                                        # 第一个if
                                                        block_info = "IF:"
                                                    elif temp_list.__len__() > single_path_list[
                                                        temp_list_num - 1].__len__():
                                                        # 升层if
                                                        block_info = block_info[:-3]
                                                        block_info = block_info + "TB:IF:"
                                                    elif temp_list.__len__() == single_path_list[
                                                        temp_list_num - 1].__len__():
                                                        # 同层if
                                                        if "else if(" in \
                                                                path_dict.get(int_to_str(temp_list)).split("@")[
                                                                    0] or "else if (" in \
                                                                path_dict.get(int_to_str(temp_list)).split("@")[0]:
                                                            block_info = block_info[:-3]
                                                            block_info = block_info + "FB:IF:"
                                                        elif "else" in path_dict.get(int_to_str(temp_list)).split("@")[
                                                            0] and "if" not in \
                                                                path_dict.get(int_to_str(temp_list)).split("@")[0]:
                                                            block_info = block_info[:-3]
                                                            block_info = block_info + "FB:"
                                                        else:
                                                            block_info = block_info[:(-3 * (temp_list.__len__()))]
                                                            block_info = block_info + "IF:"
                                                    elif temp_list.__len__() < single_path_list[
                                                        temp_list_num - 1].__len__():
                                                        # 降层if
                                                        block_info = block_info[:-3]
                                                        block_info = block_info + "IF:"
                                                    pathstatement.append(
                                                        block_info + path_dict.get(int_to_str(temp_list)).split("@")[
                                                            modular_local])
                                                    #   记录不含return的块所在的位置
                                                    if temp_list in inter:
                                                        no_return_list_dict[str(temp_list)[
                                                                            str(temp_list).index("[") + 1:str(
                                                                                temp_list).index("]")].replace(' ',
                                                                                                               "")] = pathstatement.__len__() - 1
                                                else:
                                                    if temp_list_index > 1:
                                                        #   对当前if外的return的处理
                                                        temp_modify_list = list(temp_list)
                                                        temp_modify_list.append(1)
                                                        temp_modify_list[0] += 1
                                                        temp_path_list2 = list(
                                                            path_dict.get(int_to_str(temp_list)).split("@"))
                                                        while temp_modify_list in pathnumber_list:
                                                            temp_path_list2 = [modular_local for modular_local in
                                                                               temp_path_list2 if
                                                                               modular_local not in path_dict.get(
                                                                                   int_to_str(temp_modify_list)).split(
                                                                                   "@")]
                                                            temp_modify_list[-1] += 1
                                                        judge_index = 0
                                                        for temp_path_str_list in temp_path_list2:
                                                            if judge_index == 1:
                                                                relationship.append("control")
                                                                pathstatement.append(temp_path_str_list)
                                                            if (
                                                                    "if(" in temp_path_str_list or "if (" in temp_path_str_list) or "else" in temp_path_str_list:
                                                                judge_index = 1
                                                    else:
                                                        out_if_path_judge = 0
                                                        for temp_modify_list_num, single_path in enumerate(
                                                                path_dict.get(int_to_str(temp_list)).split("@")):
                                                            # 针对类似于路径[1,1]的情况
                                                            if temp_list_num == 0:
                                                                if temp_modify_list_num == path_dict.get(
                                                                        int_to_str(temp_list)).split("@").__len__() - 1:
                                                                    pass
                                                                else:
                                                                    if "Switch:" in single_path:
                                                                        if "CB:" in path_dict.get(
                                                                                int_to_str(temp_list)).split("@")[
                                                                            temp_modify_list_num + 1]:
                                                                            relationship.append("case")
                                                                        elif "DB:" in path_dict.get(
                                                                                int_to_str(temp_list)).split("@")[
                                                                            temp_modify_list_num + 1]:
                                                                            relationship.append("default")
                                                                    else:
                                                                        if ("if" not in single_path) and (
                                                                                "else" not in single_path) and out_if_path_judge == 0:
                                                                            relationship.append("control")
                                                                        if (
                                                                                "if (" in single_path or "if(" in single_path) and (
                                                                                "else" not in single_path):
                                                                            relationship.append("true")
                                                                            block_info = "IF:"
                                                                            out_if_path_judge = 1
                                                                        elif out_if_path_judge == 1:
                                                                            block_info = "TB:"
                                                                            relationship.append("control")
                                                            else:
                                                                if temp_modify_list_num == 0:
                                                                    if temp_list.__len__() > single_path_list[
                                                                        temp_list_num - 1].__len__():
                                                                        # 升层if
                                                                        block_info = block_info[:-3]
                                                                        block_info = block_info + "TB:IF:"
                                                                    elif temp_list.__len__() == single_path_list[
                                                                        temp_list_num - 1].__len__():
                                                                        # 同层if
                                                                        if "else if(" in single_path or "else if (" in single_path:
                                                                            block_info = block_info[:-3]
                                                                            block_info = block_info + "FB:IF:"
                                                                        elif "else" in single_path and "if" not in single_path:
                                                                            block_info = block_info[:-3]
                                                                            block_info = block_info + "FB:"
                                                                        else:
                                                                            block_info = block_info[
                                                                                         :(-3 * (temp_list.__len__()))]
                                                                            block_info = block_info + "IF:"
                                                                    elif temp_list.__len__() < single_path_list[
                                                                        temp_list_num - 1].__len__():
                                                                        # 降层if
                                                                        block_info = block_info[:-3]
                                                                        block_info = block_info + "IF:"
                                                                elif temp_modify_list_num == 1:
                                                                    if "else" in \
                                                                            path_dict[int_to_str(temp_list)].split("@")[
                                                                                0] and "if" not in \
                                                                            path_dict[int_to_str(temp_list)].split("@")[
                                                                                0]:
                                                                        pass
                                                                    else:
                                                                        block_info = block_info[:-3]
                                                                        block_info = block_info + "TB:"
                                                                    if "Switch:" in single_path:
                                                                        relationship.append("control")
                                                                    elif "CB:" in single_path:
                                                                        relationship.append("case")
                                                                    elif "DB:" in single_path:
                                                                        relationship.append("default")
                                                                    else:
                                                                        relationship.append("true")
                                                                else:
                                                                    if "else" in \
                                                                            path_dict[int_to_str(temp_list)].split("@")[
                                                                                0] and "if" not in \
                                                                            path_dict[int_to_str(temp_list)].split("@")[
                                                                                0]:
                                                                        pass
                                                                    else:
                                                                        block_info = block_info[:-3]
                                                                        block_info = block_info + "TB:"
                                                                    if "Switch:" in single_path:
                                                                        if "CB:" in path_dict.get(
                                                                                int_to_str(temp_list)).split("@")[
                                                                            temp_modify_list_num + 1]:
                                                                            relationship.append("case")
                                                                        elif "DB:" in path_dict.get(
                                                                                int_to_str(temp_list)).split("@")[
                                                                            temp_modify_list_num + 1]:
                                                                            relationship.append("default")
                                                                    else:
                                                                        relationship.append("control")
                                                            pathstatement.append(block_info + single_path)
                                            block_info = ""
                                            for temp_index, temp_statement in enumerate(pathstatement):
                                                #   非硬件函数以及硬件函数调用信息的提取
                                                temp_call_function_info = get_call_function_info_pattern.findall(
                                                    temp_statement)
                                                if temp_call_function_info.__len__() != 0:
                                                    temp_modify_statement = temp_statement
                                                    while "(" in temp_modify_statement and temp_call_function_info.__len__() > 0:
                                                        if functionincall(temp_call_function_info[0],
                                                                          function_info_dict):  # 函数调用判断
                                                            if temp_call_function_info[
                                                                0] not in hard_function_name:  # 非硬件差异函数内调用的非硬件差异函数
                                                                call_normal_function_name.append(str(temp_index + 1))
                                                                call_normal_function_name.append(
                                                                    "NF:" + temp_call_function_info[
                                                                        0] + ";SF:" + os.path.basename(
                                                                        function_info_dict.get(
                                                                            temp_call_function_info[
                                                                                0])) + ";" + project_name)
                                                                call_normal_function_path.append(str(temp_index + 1))
                                                                call_normal_function_path.append(
                                                                    function_info_dict.get(temp_call_function_info[0]))
                                                            else:  # 非硬件差异函数内调用的硬件差异函数
                                                                call_hard_function_name.append(str(temp_index + 1))
                                                                call_hard_function_name.append(
                                                                    "HF:" + temp_call_function_info[
                                                                        0] + ";SF:" + os.path.basename(
                                                                        function_info_dict.get(
                                                                            temp_call_function_info[
                                                                                0])) + ";" + project_name)
                                                                call_hard_function_path.append(str(temp_index + 1))
                                                                call_hard_function_path.append(
                                                                    function_info_dict.get(temp_call_function_info[0]))
                                                        temp_modify_statement = temp_modify_statement[
                                                                                temp_modify_statement.index("(") + 1:]
                                                        temp_call_function_info = get_call_function_info_pattern.findall(
                                                            temp_modify_statement)
                                                #   当前检索的硬件差异函数内，pathstatement内使用的宏定义的提取
                                                for temp_macrodef in macrodef_name:
                                                    if temp_macrodef in temp_statement:
                                                        use_macrodef_name.append(str(temp_index + 1))
                                                        use_macrodef_name.append(temp_macrodef)
                                                #   当前检索的硬件差异函数内，pathstatement内使用的全局变量的提取
                                                for temp_useglobalvar in use_globalvar_name:
                                                    if temp_useglobalvar in temp_statement:
                                                        use_globalvar_name.append(str(temp_index + 1))
                                                        use_globalvar_name.append(temp_useglobalvar)
                                            for temp_index, temp_path in enumerate(pathstatement):
                                                if "Switch:" in pathstatement[temp_index]:
                                                    pathstatement[temp_index] = pathstatement[temp_index][
                                                                                pathstatement[temp_index].index(
                                                                                    "Switch:"):]
                                                if "CB:" in pathstatement[temp_index]:
                                                    pathstatement[temp_index] = pathstatement[temp_index][
                                                                                pathstatement[temp_index].index("CB:"):]
                                                if "DB:" in pathstatement[temp_index]:
                                                    pathstatement[temp_index] = pathstatement[temp_index][
                                                                                pathstatement[temp_index].index("DB:"):]
                                            print(pathstatement)

                                            json_file = open('medical' + str(file_number) + '.json', 'a',
                                                             encoding='utf-8')
                                            file_number += 1
                                            kgdata = defaultdict(list)
                                            kgdata["hardfunction"] = function_judge
                                            kgdata["softwarename"] = project_name
                                            kgdata["softwarepath"] = project_path
                                            kgdata["sourcename"] = sourcename
                                            kgdata["sourcepath"] = sourcepath
                                            kgdata["function_name"] = function_name
                                            kgdata["pathstatement"] = pathstatement
                                            kgdata["relationship"] = relationship
                                            kgdata["call_normal_function_name"] = call_normal_function_name
                                            kgdata["call_normal_function_path"] = call_normal_function_path
                                            kgdata["call_hard_function_name"] = call_hard_function_name
                                            kgdata["call_hard_function_path"] = call_hard_function_path
                                            kgdata["use_macrodef_name"] = use_macrodef_name
                                            kgdata["use_globalvar_name"] = use_globalvar_name

                                            json_str = json.dumps(kgdata, ensure_ascii=False)
                                            json_file.write(json_str + "\n")
                                            json_file.close()

                                            use_macrodef_name.clear()
                                            use_globalvar_name.clear()
                                            #   对不含return的块进行处理
                                            for numbers in itertools.product([0, 1], repeat=inter.__len__()):
                                                temp_pathstatement = list(pathstatement)
                                                temp_relationship = list(relationship)
                                                if 1 not in numbers:
                                                    pass
                                                else:
                                                    for index, i_2 in enumerate(numbers):
                                                        if i_2 == 1:
                                                            temp_single_pathstatement = temp_pathstatement[
                                                                no_return_list_dict[str(inter[index])[
                                                                                    str(inter[index]).index(
                                                                                        "[") + 1:str(
                                                                                        inter[index]).index(
                                                                                        "]")].replace(
                                                                    ' ', "")]]
                                                            while temp_single_pathstatement[
                                                                  :3] == "IF:" or temp_single_pathstatement[
                                                                                  :3] == "TB:" or temp_single_pathstatement[
                                                                                                  :3] == "FB:":
                                                                block_info = block_info + temp_single_pathstatement[:3]
                                                                temp_single_pathstatement = temp_single_pathstatement[
                                                                                            3:]
                                                            del temp_pathstatement[
                                                                no_return_list_dict[str(inter[index])[
                                                                                    str(inter[
                                                                                            index]).index(
                                                                                        "[") + 1:str(
                                                                                        inter[
                                                                                            index]).index(
                                                                                        "]")].replace(
                                                                    ' ', "")]]
                                                            for temp_i in range(
                                                                    path_dict[int_to_str(inter[index])].split(
                                                                        "@").__len__()):
                                                                if temp_i == path_dict[int_to_str(inter[index])].split(
                                                                        "@").__len__() - 1:
                                                                    block_info = block_info[:-3]
                                                                    block_info = block_info + "IF:"
                                                                else:
                                                                    block_info = block_info[:-3]
                                                                    block_info = block_info + "TB:"
                                                                temp_pathstatement.insert(no_return_list_dict[
                                                                                              str(inter[index])[
                                                                                              str(inter[index]).index(
                                                                                                  "[") + 1:str(
                                                                                                  inter[index]).index(
                                                                                                  "]")].replace(' ',
                                                                                                                "")],
                                                                                          block_info +
                                                                                          path_dict[int_to_str(
                                                                                              inter[index])].split("@")[
                                                                                              path_dict[int_to_str(
                                                                                                  inter[index])].split(
                                                                                                  "@").__len__() - temp_i - 1])
                                                                if temp_i == 0:
                                                                    pass
                                                                elif temp_i == path_dict[
                                                                    int_to_str(inter[index])].split(
                                                                    "@").__len__() - 1:
                                                                    temp_relationship.insert(no_return_list_dict[
                                                                                                 str(inter[index])[
                                                                                                 str(inter[
                                                                                                         index]).index(
                                                                                                     "[") + 1:str(
                                                                                                     inter[
                                                                                                         index]).index(
                                                                                                     "]")].replace(' ',
                                                                                                                   "")],
                                                                                             "true")
                                                                else:
                                                                    temp_relationship.insert(no_return_list_dict[
                                                                                                 str(inter[index])[
                                                                                                 str(inter[
                                                                                                         index]).index(
                                                                                                     "[") + 1:str(
                                                                                                     inter[
                                                                                                         index]).index(
                                                                                                     "]")].replace(' ',
                                                                                                                   "")],
                                                                                             "control")
                                                    block_info = ""
                                                    for temp_index, temp_statement in enumerate(temp_pathstatement):
                                                        #   非硬件函数以及硬件函数调用信息的提取
                                                        temp_call_function_info = get_call_function_info_pattern.findall(
                                                            temp_statement)
                                                        if temp_call_function_info.__len__() != 0:
                                                            temp_modify_statement = temp_statement
                                                            while "(" in temp_modify_statement and temp_call_function_info.__len__() > 0:
                                                                if functionincall(temp_call_function_info[0],
                                                                                  function_info_dict):  # 函数调用判断
                                                                    if temp_call_function_info[
                                                                        0] not in hard_function_name:  # 非硬件差异函数内调用的非硬件差异函数
                                                                        call_normal_function_name.append(
                                                                            str(temp_index + 1))
                                                                        call_normal_function_name.append(
                                                                            "NF:" + temp_call_function_info[
                                                                                0] + ";SF:" + os.path.basename(
                                                                                function_info_dict.get(
                                                                                    temp_call_function_info[
                                                                                        0])) + ";" + project_name)
                                                                        call_normal_function_path.append(
                                                                            str(temp_index + 1))
                                                                        call_normal_function_path.append(
                                                                            function_info_dict.get(
                                                                                temp_call_function_info[0]))
                                                                    else:  # 非硬件差异函数内调用的硬件差异函数
                                                                        call_hard_function_name.append(
                                                                            str(temp_index + 1))
                                                                        call_hard_function_name.append(
                                                                            "HF:" + temp_call_function_info[
                                                                                0] + ";SF:" + os.path.basename(
                                                                                function_info_dict.get(
                                                                                    temp_call_function_info[
                                                                                        0])) + ";" + project_name)
                                                                        call_hard_function_path.append(
                                                                            str(temp_index + 1))
                                                                        call_hard_function_path.append(
                                                                            function_info_dict.get(
                                                                                temp_call_function_info[0]))
                                                                temp_modify_statement = temp_modify_statement[
                                                                                        temp_modify_statement.index(
                                                                                            "(") + 1:]
                                                                temp_call_function_info = get_call_function_info_pattern.findall(
                                                                    temp_modify_statement)
                                                        #   当前检索的硬件差异函数内，pathstatement内使用的宏定义的提取
                                                        for temp_macrodef in macrodef_name:
                                                            if temp_macrodef in temp_statement:
                                                                use_macrodef_name.append(str(temp_index + 1))
                                                                use_macrodef_name.append(temp_macrodef)
                                                        #   当前检索的硬件差异函数内，pathstatement内使用的全局变量的提取
                                                        for temp_useglobalvar in globalvar_name:
                                                            if temp_useglobalvar in temp_statement:
                                                                use_globalvar_name.append(str(temp_index + 1))
                                                                use_globalvar_name.append(temp_useglobalvar)

                                                    for temp_index, temp_path in enumerate(temp_pathstatement):
                                                        if "Switch:" in temp_pathstatement[temp_index]:
                                                            temp_pathstatement[temp_index] = temp_pathstatement[
                                                                                                 temp_index][
                                                                                             temp_pathstatement[
                                                                                                 temp_index].index(
                                                                                                 "Switch:"):]
                                                        if "CB:" in temp_pathstatement[temp_index]:
                                                            temp_pathstatement[temp_index] = temp_pathstatement[
                                                                                                 temp_index][
                                                                                             temp_pathstatement[
                                                                                                 temp_index].index(
                                                                                                 "CB:"):]
                                                        if "DB:" in temp_pathstatement[temp_index]:
                                                            temp_pathstatement[temp_index] = temp_pathstatement[
                                                                                                 temp_index][
                                                                                             temp_pathstatement[
                                                                                                 temp_index].index(
                                                                                                 "DB:"):]
                                                    print(temp_pathstatement)

                                                    json_file = open('medical' + str(file_number) + '.json', 'a',
                                                                     encoding='utf-8')
                                                    file_number += 1
                                                    kgdata = defaultdict(list)
                                                    kgdata["hardfunction"] = function_judge
                                                    kgdata["softwarename"] = project_name
                                                    kgdata["softwarepath"] = project_path
                                                    kgdata["sourcename"] = sourcename
                                                    kgdata["sourcepath"] = sourcepath
                                                    kgdata["function_name"] = function_name
                                                    kgdata["pathstatement"] = temp_pathstatement
                                                    kgdata["relationship"] = temp_relationship
                                                    kgdata["call_normal_function_name"] = call_normal_function_name
                                                    kgdata["call_normal_function_path"] = call_normal_function_path
                                                    kgdata["call_hard_function_name"] = call_hard_function_name
                                                    kgdata["call_hard_function_path"] = call_hard_function_path
                                                    kgdata["use_macrodef_name"] = use_macrodef_name
                                                    kgdata["use_globalvar_name"] = use_globalvar_name

                                                    json_str = json.dumps(kgdata, ensure_ascii=False)
                                                    json_file.write(json_str + "\n")
                                                    json_file.close()

                                            # 清空当前函数中的所有路径信息
                                            call_normal_function_name.clear()
                                            call_normal_function_path.clear()
                                            call_hard_function_name.clear()
                                            call_hard_function_path.clear()
                                            use_macrodef_name.clear()
                                            use_globalvar_name.clear()
                                            relationship.clear()
                                            pathstatement = []
                            if "{" in content:
                                content = content.replace('{', '')
                                hard_function_brackets_number[floorblock_level[0]] += 1
                        else:
                            if hard_function_brackets_number[-1] == 0:
                                hard_function_brackets_number = hard_function_brackets_number[:-1]
                                floorblock_level = floorblock_level[:-1]
                                floorblock_level[0] -= 1
                # if、switch分支语句存放
                if floorblock_level.__len__() > 1:
                    if str(floorblock_level)[
                       str(floorblock_level).index("[") + 1:str(floorblock_level).index("]")].replace(' ',
                                                                                                      "") not in path_dict.keys():
                        if basepath != "":
                            if switch_path_judge == 1:
                                switch_condition = basepath + "@" + switch_condition
                            path_dict[str(floorblock_level)[
                                      str(floorblock_level).index("[") + 1:str(floorblock_level).index("]")].replace(
                                ' ', "")] = switch_condition
                            basepath = ""
                        else:
                            if switch_path_judge == 1:
                                if "switch" in content:
                                    path_dict[str(floorblock_level)[
                                              str(floorblock_level).index("[") + 1:str(floorblock_level).index(
                                                  "]")].replace(
                                        ' ', "")] = switch_condition
                                elif "case " in content:
                                    path_dict[str(floorblock_level)[
                                              str(floorblock_level).index("[") + 1:str(floorblock_level).index(
                                                  "]")].replace(
                                        ' ', "")] = switch_condition + "@" + "CB:" + content.strip()
                                elif "default:" in content:
                                    path_dict[str(floorblock_level)[
                                              str(floorblock_level).index("[") + 1:str(floorblock_level).index(
                                                  "]")].replace(
                                        ' ', "")] = switch_condition + "@" + "DB:" + content.strip()
                            else:
                                path_dict[str(floorblock_level)[
                                          str(floorblock_level).index("[") + 1:str(floorblock_level).index(
                                              "]")].replace(
                                    ' ', "")] = content.strip()
                        # 将当前content同时插入所有上级层
                        for temp_key in path_dict.keys():
                            temp_key_list = temp_key.split(",")
                            if content.strip() not in path_dict[
                                temp_key] and floorblock_level.__len__() > temp_key_list.__len__():
                                temp_index = 1
                                judge_i = 0
                                while temp_index < temp_key_list.__len__():
                                    if temp_key_list[temp_index] == str(floorblock_level[temp_index]):
                                        judge_i += 1
                                    temp_index += 1
                                if judge_i == temp_key_list.__len__() - 1:
                                    path_dict[temp_key] = path_dict[temp_key] + "@" + content.strip()
                    else:
                        for temp_key in path_dict.keys():
                            temp_key_list = temp_key.split(",")
                            if temp_key_list == list(map(str, floorblock_level)):
                                path_dict[temp_key] = path_dict[temp_key] + "@" + content.strip()
                            elif floorblock_level.__len__() > temp_key_list.__len__():
                                temp_index = 1
                                judge_i = 0
                                while temp_index < temp_key_list.__len__():
                                    if temp_key_list[temp_index] == str(floorblock_level[temp_index]):
                                        judge_i += 1
                                    temp_index += 1
                                if judge_i == temp_key_list.__len__() - 1:
                                    path_dict[temp_key] = path_dict[temp_key] + "@" + content.strip()
    time_end = time.time()  # 结束计时
    time_c = time_end - time_start  # 运行所花时间
    print('time cost', time_c, 's')


# 从字符串中的指定索引中删除字符
def remove_char(main_str, n):
    front = main_str[:n]  # up to but not including n
    back = main_str[n + 1:]  # n+1 till the end of string
    return front + back


# 分支号int->str
def int_to_str(int_list):
    str_list = str(int_list)
    str_list = str_list[str_list.index("[") + 1:str_list.index("]")].replace(' ', "")
    return str_list


# 按分支号划分路径
def difffunction_path(pathnumber_list, path_list, floornumber_list, path_dict, temp_path_list, no_return_list):
    while floornumber_list in pathnumber_list:
        if temp_path_list:
            if floornumber_list.__len__() < temp_path_list[-1].__len__():
                #   存放嵌套外有return的情况
                temp_list = list(temp_path_list[-1])
                temp_list2 = list(temp_path_list[-1])
                del temp_list[-1]
                temp_list[0] -= 1
                temp_path_list2 = list(path_dict.get(int_to_str(floornumber_list)).split("@"))
                while temp_list2 in pathnumber_list:
                    temp_path_list2 = set(temp_path_list2).difference(
                        set(path_dict.get(int_to_str(floornumber_list)).split("@")))
                    temp_list2[-1] -= 1
                for temp_i in temp_path_list2:
                    if "return " in temp_i:
                        temp_path_list.append(list(temp_list))
                        path_list.append(list(temp_path_list))
                        del temp_path_list[-1]
                #
                if ("if(" in path_dict.get(int_to_str(floornumber_list)).split("@")[0] or "if (" in
                    path_dict.get(int_to_str(floornumber_list)).split("@")[0]) and "else" not in \
                        path_dict.get(int_to_str(floornumber_list)).split("@")[0]:
                    pass
                else:
                    while temp_path_list[-1].__len__() > floornumber_list.__len__():
                        del temp_path_list[-1]
        temp_int_list = list(floornumber_list)
        temp_int_list[0] += 1
        temp_int_list.append(1)
        if temp_int_list in pathnumber_list:
            if "Switch:" not in path_dict.get(int_to_str(floornumber_list)):
                temp_path_list.append(list(floornumber_list))
            difffunction_path(pathnumber_list, path_list, temp_int_list, path_dict, temp_path_list, no_return_list)
        elif "return " in path_dict.get(int_to_str(floornumber_list)):
            temp_path_list.append(list(floornumber_list))
            path_list.append(list(temp_path_list))
            if "Switch:" in path_dict.get(int_to_str(floornumber_list)):
                del temp_path_list[-1]
        elif "return " not in path_dict.get(int_to_str(floornumber_list)):
            temp_path_list.append(list(floornumber_list))
            no_return_list.append(list(floornumber_list))

        floornumber_list[-1] += 1


# 判断函数是否调用
def functionincall(callfunctionname, function_info_dict):
    for key in function_info_dict.keys():  # 遍历字典中所有key值，若当前函数名存在于字典中，则返回True
        if key == callfunctionname:
            return True
    return False


# 读取所有硬件差异函数名并存放
def hard_function_search(hard_function_name):
    hard_function_name.append("hard_diff_func_1")
    hard_function_name.append("hard_diff_func_2")
    hard_function_name.append("hard_diff_func_3")
    hard_function_name.append("hard_diff_func_4")
    hard_function_name.append("hard_diff_func_5")


# 读取目标工程文件夹下（包括子目录下）所有.c文件，并获取其路径
def read_files(path, body_list_name, head_list_name):
    for file in os.listdir(path):
        file_path = os.path.join(path, file)
        if os.path.isdir(file_path):  # 若路径下存在子目录，则继续使用递归继续读取
            read_files(file_path, body_list_name, head_list_name)
        elif os.path.splitext(file_path)[1] == '.c':  # 根据文件扩展名判断并获取.c文件
            body_list_name.append(file_path)  # 存放符合要求文件的路径
        elif os.path.splitext(file_path)[1] == '.h':
            head_list_name.append(file_path)  # 存放符合要求文件的路径


# 读取工程下所有自定义数据类型
def returntype_search(listname, returntype_list):
    index = 0  # 判断是否为结构体类型 0:不是 1:是
    function_brackets_number = 0  # # 记录当前结构体中的"{}"是否成对
    returntype_list.append("VOID")
    returntype_list.append("void")
    returntype_list.append("char")
    returntype_list.append("short")
    returntype_list.append("int")
    returntype_list.append("float")
    returntype_list.append("long")
    returntype_list.append("double")
    returntype_list.append("bool")
    returntype_list.append("UINT32")
    returntype_list.append("uint32_t")
    get_returntype_pattern = re.compile(r"typedef\s(struct).*\s(\w+)?")
    get_custom_returntype_pattern = re.compile(r"typedef.*\s(\w+)")
    for pyFilePath in listname:
        contents = read(pyFilePath)
        for content in contents:
            if "/*" in content:
                content = content[:content.index("/*")]
            if "*/" in content:
                content = content[content.index("*/") + 2:]
            if "//" in content:
                content = content[:content.index("//")]
            if "{" in content:
                function_brackets_number += 1
            if "}" in content:
                function_brackets_number -= 1
            if function_brackets_number == 0 and index == 1:
                returntype_list.append(content[content.index("}") + 1:content.index(";")])
                index = 0
            returntype_info = get_returntype_pattern.findall(content)
            if returntype_info.__len__() > 0:
                index = 1
            else:
                returntype_info = get_custom_returntype_pattern.findall(content)
                if returntype_info.__len__() > 0:
                    returntype_list.append(returntype_info[0])


# 读取工程下所有函数定义行并保存函数名和所在文件路径
def function_search(listname, function_info_dict, returntype_list):
    pattern = re.compile(r"(static)*\s*(\w+)\s(\*?)(\w+)\s*\(.*\)")
    for pyFilePath in listname:
        function_brackets_number = 0
        contents = read(pyFilePath)
        for content in contents:
            if "/*" in content:
                content = content[:content.index("/*")]
            function_info = pattern.findall(content)
            if function_info.__len__() > 0 and function_brackets_number == 0:
                if function_info[0][1] in returntype_list:
                    function_info_dict[function_info[0][3]] = pyFilePath  # 以键值对的形式存放函数名以及其所在文件路径
            if "{" in content:
                function_brackets_number += 1
            if "}" in content:
                function_brackets_number -= 1


#   全局变量以及宏定义使用判断
def macrodef_globalvar_search(macrodef_name, globalvar_name):
    macrodef_name.append("VOS_FALSE0")
    macrodef_name.append("VOS_TRUE0")
    macrodef_name.append("VOS_FALSE1")
    macrodef_name.append("VOS_FALSE2")
    macrodef_name.append("VOS_FALSE3")
    macrodef_name.append("VOS_TRUE1")
    macrodef_name.append("VOS_TRUE2")
    macrodef_name.append("VOS_TRUE2_2")
    macrodef_name.append("VOS_TRUE3")
    macrodef_name.append("VOS_TRUE4")
    globalvar_name.append("tm_info")


# 扫描源文件
def read(filepath):
    readfile = open(filepath, "r", encoding='utf-8')  # 从filePath文件中获取指定文件的路径
    contents = readfile.readlines()  # 扫描文件中的所有内容并以列表的形式存储
    readfile.close()
    return contents


if __name__ == '__main__':
    main()
